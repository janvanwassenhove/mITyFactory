````instructions
# GitHub Copilot Instructions for {{app_name}}

## Project Overview

{{app_name}} is a modern .NET 10 fullstack application with Blazor Web App frontend and REST API backend, generated by mITyFactory.

## Tech Stack

- **Runtime**: .NET 10 / C# 13
- **Web Frontend**: Blazor Web App (SSR + Interactive Server)
- **API Backend**: ASP.NET Core Minimal APIs
- **Database**: PostgreSQL with Entity Framework Core
- **Messaging**: MassTransit with RabbitMQ
- **Logging**: Serilog with structured logging
- **Tracing**: OpenTelemetry with OTLP exporter
- **Testing**: xUnit, FluentAssertions, NSubstitute, Testcontainers

## Project Structure

```
{{app_name}}/
├── src/
│   ├── {{app_name}}.Web/           # Blazor Web App
│   ├── {{app_name}}.Api/           # REST API
│   ├── {{app_name}}.Application/   # Use cases & services
│   ├── {{app_name}}.Domain/        # Entities & repositories
│   ├── {{app_name}}.Infrastructure/# EF Core, repositories
│   └── {{app_name}}.Shared/        # DTOs & shared models
├── tests/
│   ├── {{app_name}}.Tests.Unit/
│   └── {{app_name}}.Tests.Integration/
├── deploy/
│   └── helm/                       # Kubernetes Helm charts
├── Directory.Build.props           # Central build properties
├── Directory.Packages.props        # Central package versions
└── docker-compose.yml              # Local development
```

---

## Code Style Rules

### Entity Framework Core

```csharp
// Use async methods
public async Task<Item?> GetByIdAsync(Guid id, CancellationToken ct = default)
{
    return await _context.Items.FirstOrDefaultAsync(x => x.Id == id, ct);
}

// Configure entities in separate configuration classes
public class ItemConfiguration : IEntityTypeConfiguration<Item>
{
    public void Configure(EntityTypeBuilder<Item> builder)
    {
        builder.ToTable("items");
        builder.Property(x => x.Name).HasMaxLength(200).IsRequired();
    }
}
```

### Minimal API Endpoints

```csharp
// Group endpoints by feature
public static class ItemEndpoints
{
    public static void MapItemEndpoints(this IEndpointRouteBuilder routes)
    {
        var group = routes.MapGroup("/api/v1/items")
            .WithTags("Items")
            .WithOpenApi();

        group.MapGet("/", GetAllItems)
            .WithName("GetAllItems")
            .Produces<List<ItemDto>>();
    }
    
    private static async Task<Ok<List<ItemDto>>> GetAllItems(
        IItemService itemService,
        CancellationToken ct)
    {
        var items = await itemService.GetAllAsync(ct);
        return TypedResults.Ok(items.ToList());
    }
}
```

### MassTransit Consumers

```csharp
public class ItemCreatedConsumer : IConsumer<ItemCreatedEvent>
{
    private readonly ILogger<ItemCreatedConsumer> _logger;

    public ItemCreatedConsumer(ILogger<ItemCreatedConsumer> logger)
    {
        _logger = logger;
    }

    public Task Consume(ConsumeContext<ItemCreatedEvent> context)
    {
        _logger.LogInformation("Item created: {ItemId}", context.Message.Id);
        return Task.CompletedTask;
    }
}
```

### Blazor Components

```razor
@page "/items"
@rendermode InteractiveServer
@inject IHttpClientFactory HttpClientFactory

<PageTitle>Items</PageTitle>

@if (_loading)
{
    <p>Loading...</p>
}
else
{
    <ItemList Items="_items" OnDelete="DeleteItem" />
}

@code {
    private List<ItemDto> _items = new();
    private bool _loading = true;

    protected override async Task OnInitializedAsync()
    {
        var client = HttpClientFactory.CreateClient("Api");
        _items = await client.GetFromJsonAsync<List<ItemDto>>("api/v1/items") ?? new();
        _loading = false;
    }
}
```

---

## Testing Requirements

### Unit Tests

- Test all service methods
- Use NSubstitute for mocking
- Use Bogus for test data generation
- Target 80%+ coverage

```csharp
public class ItemServiceTests
{
    private readonly IItemRepository _repository = Substitute.For<IItemRepository>();
    private readonly ItemService _sut;

    [Fact]
    public async Task GetByIdAsync_WhenExists_ReturnsItem()
    {
        // Arrange
        var item = new Faker<Item>().Generate();
        _repository.GetByIdAsync(item.Id, Arg.Any<CancellationToken>()).Returns(item);

        // Act
        var result = await _sut.GetByIdAsync(item.Id);

        // Assert
        result.Should().NotBeNull();
        result!.Id.Should().Be(item.Id);
    }
}
```

### Integration Tests

- Use Testcontainers for PostgreSQL
- Test API endpoints with WebApplicationFactory

```csharp
public class ItemEndpointsTests : IClassFixture<IntegrationTestFactory>
{
    private readonly HttpClient _client;

    [Fact]
    public async Task CreateItem_ReturnsCreatedItem()
    {
        var response = await _client.PostAsJsonAsync("/api/v1/items", 
            new { Name = "Test" });
        
        response.StatusCode.Should().Be(HttpStatusCode.Created);
    }
}
```

---

## Package Management

All package versions are centralized in `Directory.Packages.props`:

```xml
<!-- Add new packages to Directory.Packages.props -->
<PackageVersion Include="NewPackage" Version="1.0.0" />

<!-- Reference in project without version -->
<PackageReference Include="NewPackage" />
```

---

## DO ✓

- Use async/await for all I/O operations
- Use CancellationToken in all async methods
- Add structured logging with meaningful context
- Create separate configuration classes for EF entities
- Use TypedResults in Minimal API endpoints
- Test with Testcontainers for integration tests
- Keep DTOs in Shared project

## DON'T ✗

- Don't specify package versions in individual .csproj files
- Don't use synchronous database calls
- Don't expose domain entities through APIs (use DTOs)
- Don't inject DbContext directly into endpoints
- Don't skip CancellationToken propagation
- Don't hardcode connection strings
````
