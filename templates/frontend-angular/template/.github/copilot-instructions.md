# GitHub Copilot Instructions for {{app_name}}

## Project Overview

{{app_name}} is an Angular SPA generated by mITyFactory.

## Tech Stack

- **Frontend**: Angular 17+
- **Language**: TypeScript
- **Build**: Angular CLI
- **Testing**: Jasmine, Karma
- **Styling**: SCSS

## Project Structure

```
{{app_name}}/
├── src/
│   ├── app/
│   │   ├── core/                   # Singleton services, guards
│   │   ├── shared/                 # Shared components, pipes, directives
│   │   ├── features/               # Feature modules
│   │   └── app.component.ts
│   ├── assets/
│   └── environments/
├── .specify/                       # Spec Kit
└── .github/                        # GitHub configuration
```

---

## Code Style Rules

### Angular Patterns

```typescript
// Component
@Component({
  selector: 'app-item-list',
  templateUrl: './item-list.component.html',
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class ItemListComponent {
  private readonly itemService = inject(ItemService);
  
  items$ = this.itemService.getItems();
}

// Service
@Injectable({ providedIn: 'root' })
export class ItemService {
  private readonly http = inject(HttpClient);

  getItems(): Observable<Item[]> {
    return this.http.get<Item[]>('/api/v1/items');
  }
}
```

---

## Testing Requirements

### Unit Tests
- Test all services and components
- Use TestBed for Angular testing
- Target 80%+ coverage

```typescript
describe('ItemService', () => {
  let service: ItemService;
  let httpMock: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule]
    });
    service = TestBed.inject(ItemService);
    httpMock = TestBed.inject(HttpTestingController);
  });

  it('should fetch items', () => {
    service.getItems().subscribe(items => {
      expect(items.length).toBe(1);
    });
    httpMock.expectOne('/api/v1/items').flush([{ id: 1 }]);
  });
});
```

---

## Accessibility (A11Y) Requirements

**CRITICAL**: Target WCAG 2.1 AA compliance.

### Angular A11Y Patterns

```typescript
// Component with accessibility
@Component({
  selector: 'app-dialog',
  template: `
    <div 
      role="dialog" 
      aria-modal="true"
      aria-labelledby="dialog-title"
      (keydown.escape)="close()"
      cdkTrapFocus
    >
      <h2 id="dialog-title">{{ title }}</h2>
      <div aria-live="polite">{{ statusMessage }}</div>
      <button (click)="close()" aria-label="Close dialog">
        <span aria-hidden="true">&times;</span>
      </button>
    </div>
  `
})
export class DialogComponent {
  @Input() title = '';
  statusMessage = '';
}
```

### Use Angular CDK A11y Module

```typescript
import { A11yModule } from '@angular/cdk/a11y';

@NgModule({
  imports: [A11yModule]
})
export class AppModule {}
```

### A11Y Checklist

- [ ] All images have `alt` text
- [ ] All form inputs have associated labels
- [ ] Color contrast meets 4.5:1 minimum
- [ ] Focus indicators are visible
- [ ] Keyboard navigation works throughout
- [ ] Use `cdkTrapFocus` for modals
- [ ] Announce route changes to screen readers
- [ ] Test with axe-core or Lighthouse

---

## Factory Alignment

This application follows mITyFactory principles:

1. **Spec-driven**: All features defined in `.specify/features/`
2. **Container-first**: Runs in Docker/nginx containers
3. **Deterministic**: Reproducible builds
4. **Quality gates**: Tests, lints, and type checks

---

## DO ✓

- Use standalone components where possible
- Use signals for state management
- Write tests for components and services
- Follow the spec in `.specify/`
- Use OnPush change detection

## DON'T ✗

- Use `any` type
- Commit secrets
- Skip unit tests
- Use default change detection without reason
- Subscribe without unsubscribing
