//! Example stations for the create-app workflow.
//!
//! These stations demonstrate the station implementation pattern:
//! - ScaffoldStation: Creates project structure from templates
//! - ValidateStation: Validates the generated project
//! - CommitStation: Commits the project to version control

use std::fs;
use std::path::PathBuf;
use std::process::Command;

use async_trait::async_trait;
use tracing::{debug, info, warn};

use crate::context::WorkflowContext;
use crate::error::CoreResult;
use crate::station::{Artifact, ArtifactType, Station, StationInput, StationOutput, StationResult};

/// Station that scaffolds a new application from templates.
#[derive(Debug, Default)]
pub struct ScaffoldStation;

impl ScaffoldStation {
    pub fn new() -> Self {
        Self
    }

    /// Copy template files to the output directory.
    fn copy_template(
        &self,
        template_path: &PathBuf,
        output_path: &PathBuf,
        app_name: &str,
    ) -> CoreResult<Vec<PathBuf>> {
        let mut created_files = Vec::new();

        if !template_path.exists() {
            warn!("Template path {:?} does not exist, creating minimal structure", template_path);
            // Create minimal structure
            fs::create_dir_all(output_path.join("src"))?;

            // Create a minimal main file
            let main_content = format!(
                "// {} - Generated by mITyFactory\n\nfn main() {{\n    println!(\"Hello from {}!\");\n}}\n",
                app_name, app_name
            );
            let main_path = output_path.join("src").join("main.rs");
            fs::write(&main_path, main_content)?;
            created_files.push(main_path);

            // Create Cargo.toml
            let cargo_content = format!(
                r#"[package]
name = "{}"
version = "0.1.0"
edition = "2021"

[dependencies]
"#,
                app_name
            );
            let cargo_path = output_path.join("Cargo.toml");
            fs::write(&cargo_path, cargo_content)?;
            created_files.push(cargo_path);

            return Ok(created_files);
        }

        // Recursively copy template directory
        self.copy_dir_recursive(template_path, output_path, app_name, &mut created_files)?;

        Ok(created_files)
    }

    fn copy_dir_recursive(
        &self,
        src: &PathBuf,
        dst: &PathBuf,
        app_name: &str,
        created_files: &mut Vec<PathBuf>,
    ) -> CoreResult<()> {
        fs::create_dir_all(dst)?;

        for entry in fs::read_dir(src)? {
            let entry = entry?;
            let path = entry.path();
            let file_name = entry.file_name();
            let dst_path = dst.join(&file_name);

            if path.is_dir() {
                self.copy_dir_recursive(&path, &dst_path, app_name, created_files)?;
            } else {
                // Read and replace placeholders
                let content = fs::read_to_string(&path)
                    .unwrap_or_else(|_| String::new());
                let content = content.replace("{{app_name}}", app_name);
                let content = content.replace("{{APP_NAME}}", &app_name.to_uppercase());

                fs::write(&dst_path, content)?;
                created_files.push(dst_path);
            }
        }

        Ok(())
    }
}

#[async_trait]
impl Station for ScaffoldStation {
    fn name(&self) -> &str {
        "scaffold"
    }

    fn description(&self) -> &str {
        "Creates project structure from templates"
    }

    fn input(&self) -> StationInput {
        StationInput::new()
    }

    fn output(&self) -> StationOutput {
        StationOutput::new()
            .produces_key("scaffolded_files")
            .produces_artifact("project-structure")
    }

    async fn execute(&self, context: &mut WorkflowContext) -> CoreResult<StationResult> {
        info!("Scaffolding application: {}", context.app_name);

        // Determine template path based on stack
        let template_path = context
            .templates_path()
            .join(context.stack.as_str());

        debug!("Using template from {:?}", template_path);

        // Ensure output directory exists
        fs::create_dir_all(&context.output_path)?;

        // Copy template files
        let created_files = self.copy_template(
            &template_path,
            &context.output_path,
            &context.app_name,
        )?;

        info!("Created {} files", created_files.len());

        // Record output
        context.set_output(
            "scaffolded_files",
            serde_json::json!(created_files
                .iter()
                .map(|p| p.to_string_lossy().to_string())
                .collect::<Vec<_>>()),
        );

        let mut result = StationResult::success("scaffold");

        // Add artifact
        let artifact = Artifact::new(
            "project-structure",
            ArtifactType::SourceCode,
            context.output_path.clone(),
        );
        result = result.with_artifact(artifact);

        Ok(result)
    }
}

/// Station that validates the generated project.
#[derive(Debug, Default)]
pub struct ValidateStation;

impl ValidateStation {
    pub fn new() -> Self {
        Self
    }

    /// Check if required files exist.
    fn check_required_files(&self, output_path: &PathBuf, stack: &str) -> CoreResult<Vec<String>> {
        let mut issues = Vec::new();

        // Common files that should exist
        let required = match stack {
            s if s.starts_with("rust") => vec!["Cargo.toml", "src/main.rs"],
            s if s.starts_with("python") => vec!["requirements.txt", "main.py"],
            s if s.starts_with("java") => vec!["pom.xml", "src/main/java"],
            s if s.starts_with("dotnet") => vec!["*.csproj"],
            _ => vec![],
        };

        for file in required {
            let path = output_path.join(file);
            if !path.exists() && !file.contains('*') {
                issues.push(format!("Missing required file: {}", file));
            }
        }

        Ok(issues)
    }
}

#[async_trait]
impl Station for ValidateStation {
    fn name(&self) -> &str {
        "validate"
    }

    fn description(&self) -> &str {
        "Validates the generated project structure and configuration"
    }

    fn input(&self) -> StationInput {
        StationInput::new()
            .optional_key("scaffolded_files")
    }

    fn output(&self) -> StationOutput {
        StationOutput::new()
            .produces_key("validation_issues")
            .produces_key("validation_passed")
    }

    fn dependencies(&self) -> Vec<String> {
        vec!["scaffold".to_string()]
    }

    async fn execute(&self, context: &mut WorkflowContext) -> CoreResult<StationResult> {
        info!("Validating project: {}", context.app_name);

        // Check if output directory exists
        if !context.output_path.exists() {
            return Ok(StationResult::failure(
                "validate",
                "Project directory does not exist",
            ));
        }

        // Check required files
        let issues = self.check_required_files(&context.output_path, context.stack.as_str())?;

        context.set_output("validation_issues", serde_json::json!(issues));
        context.set_output("validation_passed", serde_json::json!(issues.is_empty()));

        if issues.is_empty() {
            info!("Validation passed");
            Ok(StationResult::success("validate"))
        } else {
            warn!("Validation found {} issue(s)", issues.len());
            for issue in &issues {
                warn!("  - {}", issue);
            }
            // Return success but log warnings - not a hard failure
            let mut result = StationResult::success("validate");
            result.message = Some(format!("Completed with {} warning(s)", issues.len()));
            Ok(result)
        }
    }
}

/// Station that commits the project to version control.
#[derive(Debug, Default)]
pub struct CommitStation;

impl CommitStation {
    pub fn new() -> Self {
        Self
    }

    /// Initialize git repository if needed.
    fn init_git(&self, path: &PathBuf) -> CoreResult<bool> {
        let git_dir = path.join(".git");
        if git_dir.exists() {
            debug!("Git repository already exists");
            return Ok(false);
        }

        info!("Initializing git repository");

        let output = Command::new("git")
            .args(["init"])
            .current_dir(path)
            .output()?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            warn!("Git init failed: {}", stderr);
            // Don't fail the station, git might not be available
            return Ok(false);
        }

        Ok(true)
    }

    /// Create initial commit.
    fn create_commit(&self, path: &PathBuf, message: &str) -> CoreResult<bool> {
        // Add all files
        let add_output = Command::new("git")
            .args(["add", "."])
            .current_dir(path)
            .output()?;

        if !add_output.status.success() {
            let stderr = String::from_utf8_lossy(&add_output.stderr);
            warn!("Git add failed: {}", stderr);
            return Ok(false);
        }

        // Create commit
        let commit_output = Command::new("git")
            .args(["commit", "-m", message])
            .current_dir(path)
            .output()?;

        if !commit_output.status.success() {
            let stderr = String::from_utf8_lossy(&commit_output.stderr);
            // "nothing to commit" is not an error
            if stderr.contains("nothing to commit") {
                debug!("Nothing to commit");
                return Ok(true);
            }
            warn!("Git commit failed: {}", stderr);
            return Ok(false);
        }

        Ok(true)
    }
}

#[async_trait]
impl Station for CommitStation {
    fn name(&self) -> &str {
        "commit"
    }

    fn description(&self) -> &str {
        "Commits the project to version control"
    }

    fn input(&self) -> StationInput {
        StationInput::new()
            .optional_key("validation_passed")
    }

    fn output(&self) -> StationOutput {
        StationOutput::new()
            .produces_key("commit_hash")
            .produces_key("git_initialized")
    }

    fn dependencies(&self) -> Vec<String> {
        vec!["validate".to_string()]
    }

    async fn execute(&self, context: &mut WorkflowContext) -> CoreResult<StationResult> {
        info!("Committing project: {}", context.app_name);

        let initialized = self.init_git(&context.output_path)?;
        context.set_output("git_initialized", serde_json::json!(initialized));

        let commit_message = format!("Initial commit: {} ({})", context.app_name, context.stack);
        let committed = self.create_commit(&context.output_path, &commit_message)?;

        if committed {
            // Try to get commit hash
            let output = Command::new("git")
                .args(["rev-parse", "HEAD"])
                .current_dir(&context.output_path)
                .output();

            if let Ok(output) = output {
                if output.status.success() {
                    let hash = String::from_utf8_lossy(&output.stdout).trim().to_string();
                    context.set_output("commit_hash", serde_json::json!(hash));
                    info!("Created commit: {}", &hash[..8.min(hash.len())]);
                }
            }
        }

        Ok(StationResult::success("commit"))
    }
}

/// Create a registry with the default create-app stations.
pub fn create_app_registry() -> crate::registry::StationRegistry {
    use std::sync::Arc;

    let mut registry = crate::registry::StationRegistry::new();
    registry.register(Arc::new(ScaffoldStation::new()));
    registry.register(Arc::new(ValidateStation::new()));
    registry.register(Arc::new(CommitStation::new()));
    registry
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::context::StackType;
    use tempfile::TempDir;

    #[tokio::test]
    async fn test_scaffold_station() {
        let temp_dir = TempDir::new().unwrap();
        let mut context = WorkflowContext::new(
            temp_dir.path().to_path_buf(),
            "test-app",
            StackType::RustApi,
        );
        context.output_path = temp_dir.path().join("output");

        let station = ScaffoldStation::new();
        let result = station.execute(&mut context).await.unwrap();

        assert!(result.success);
        assert!(context.output_path.exists());
        assert!(context.output_path.join("src").exists());
    }

    #[tokio::test]
    async fn test_validate_station() {
        let temp_dir = TempDir::new().unwrap();
        let output_path = temp_dir.path().join("output");
        fs::create_dir_all(&output_path).unwrap();

        // Create some files
        fs::create_dir_all(output_path.join("src")).unwrap();
        fs::write(output_path.join("Cargo.toml"), "[package]\nname = \"test\"").unwrap();
        fs::write(output_path.join("src/main.rs"), "fn main() {}").unwrap();

        let mut context = WorkflowContext::new(
            temp_dir.path().to_path_buf(),
            "test-app",
            StackType::RustApi,
        );
        context.output_path = output_path;

        let station = ValidateStation::new();
        let result = station.execute(&mut context).await.unwrap();

        assert!(result.success);
    }

    #[test]
    fn test_create_app_registry() {
        let registry = create_app_registry();

        assert!(registry.contains("scaffold"));
        assert!(registry.contains("validate"));
        assert!(registry.contains("commit"));
        assert_eq!(registry.len(), 3);
    }
}
